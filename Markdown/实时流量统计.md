 * Maven工程UserBehaviorAnalysis子模块NetworkFlowAnalysis

### 1.基于服务器log的热门页面浏览量统计
实现热门网页浏览数的统计，也就是读取服务器日志中的每一行log，统计在一段时间内用户访问每一个url的次数，然后排序输出显示。
每隔5秒，输出最近10分钟内访问量最多的前N个URL。
需要注意的是，原始日志中的时间是“dd/MM/yyyy:HH:mm:ss”的形式，需要定义一个DateTimeFormat将其转换为我们需要的时间戳格式。

```scala
val sdf = new SimpleDateFormat("dd/MM/yyyy:HH:mm:ss")
val timestamp = sdf.parse(linearray(3)).getTime
ApacheLogEvent(
    linearray(0), 
    linearray(2), 
    timestamp, 
    linearray(5), 
    linearray(6)
)
```

### 2.基于埋点日志数据的网络流量统计
我们发现，从web服务器log中得到的url，往往更多的是请求某个资源地址`/*.js、/*.css`，如果要针对页面进行统计往往还需要进行过滤。而在实际电商应用中，相比每个单独页面的访问量，我们可能更加关心整个电商网站的网络流量。这个指标，除了合并之前每个页面的统计结果之外，还可以通过统计埋点日志数据中的“pv”行为来得到。
#### 2.1 网站总浏览量(PV)的统计
衡量网站流量一个最简单的指标，就是网站的页面浏览量(Page View，PV)。用户每次打开一个页面便记录1次PV，多次打开同一页面则浏览量累计。一般来说，PV与来访者的数量成正比，但是PV并不直接决定页面的真实来访者数量，如同一个来访者通过不断的刷新页面，也可以制造出非常高的PV。
我们知道，用户浏览页面时，会从浏览器向网络服务器发出一个请求(Request)，网络服务器接到这个请求后，会将该请求对应的一个网页(Page)发送给浏览器，从而产生了一个PV。所以我们的统计方法，可以是从web服务器的日志中去提取对应的页面访问然后统计，就向上一节中的做法一样；也可以直接从埋点日志中提取用户发来的页面请求，从而统计出总浏览量。
所以，接下来我们用UserBehavior.csv作为数据源，实现一个网站总浏览量的统计。我们可以设置滚动时间窗口，实时统计每小时内的网站PV。


#### 2.2 网站独立访客数(UV)的统计
在实际应用中，除了同一用户的浏览行为，我们往往还会关注，在一段时间内到底有多少不同的用户访问了网站。
另外一个统计流量的重要指标是网站的独立访客数(Unique Visitor，UV)。UV指的是一段时间(比如一小时)内访问网站的总人数，1天内同一访客的多次访问只记录为一个访客。通过IP和cookie一般是判断UV值的两种方式。当客户端第一次访问某个网站服务器的时候，网站服务器会给这个客户端的电脑发出一个Cookie，通常放在这个客户端电脑的C盘当中。在这个Cookie中会分配一个独一无二的编号，这其中会记录一些访问服务器的信息，如访问时间，访问了哪些页面等等。当你下次再访问这个服务器的时候，服务器就可以直接从你的电脑中找到上一次放进去的Cookie文件，并且对其进行一些更新，但那个独一无二的编号是不会变的。
当然，对于UserBehavior数据源来说，我们直接可以根据userId来区分不同的用户。


#### 2.3 使用布隆过滤器的UV统计
在上节的例子中，我们把所有数据的userId都存在了窗口计算的状态里，在窗口收集数据的过程中，状态会不断增大。一般情况下，只要不超出内存的承受范围，这种做法也没什么问题；但如果我们遇到的数据量很大呢？
把所有数据暂存放到内存里，显然不是一个好注意。我们会想到，可以利用redis这种内存级k-v数据库，为我们做一个缓存。但如果我们遇到的情况非常极端，数据大到惊人呢？比如上亿级的用户，要去重计算UV。
如果放到redis中，亿级的用户id(每个20字节左右的话)可能需要几G甚至几十G的空间来存储。当然放到redis中，用集群进行扩展也不是不可以，但明显代价太大了。
一个更好的想法是，其实我们不需要完整地存储用户ID的信息，只要知道他在不在就行了。所以其实我们可以进行压缩处理，用一位(bit)就可以表示一个用户的状态。这个思想的具体实现就是布隆过滤器(Bloom Filter)。
本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构(probabilistic data structure)，特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。
它本身是一个很长的二进制向量，既然是二进制的向量，那么显而易见的，存放的不是0，就是1。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
我们的目标就是，利用某种方法(一般是Hash函数)把每个数据，对应到一个位图的某一位上去；如果数据存在，那一位就是1，不存在则为0。

注意这里我们用到了redis连接存取数据，所以需要加入redis客户端的依赖：
```xml
<dependencies>
    <dependency>
        <groupId>redis.clients</groupId>
        <artifactId>jedis</artifactId>
        <version>2.8.1</version>
    </dependency>
</dependencies>
```

